pragma solidity ^0.8.11;

contract BengalCatCoin is ERC20, Ownable {
    using SafeMath for uint256;
    using SafeMathInt for int256;
    using SafeMathInt for int8;
    using SafeMath for uint8;
    using Address for address payable;

    /** Variables and Parameters */
    IUniswapV2Router02 public uniswapV2Router;
    address public uniswapV2Pair;
    address public DEAD = 0x000000000000000000000000000000000000dEaD;
    address payable public BaseAddress;
    address public CEO = 0x41D3ff56bB6b4a67172e4802C03B062BAb554F87;

    bool private swapping;
    bool public stakingEnabled = false;
    bool public tradingEnabled = false;
    uint256 totalTokenSupply = (10_000_000_000) * (10**18);
    mapping(address => bool) private _isExcludedFromFee;

    mapping(address => bool) public isTxLimitExempt;
    mapping(address => uint256) private _tOwned;
    mapping(address => bool) private _isExcluded;
    mapping(address => bool) private _isExcludedFromMaxWallet;

    uint256 public sellAmount = 0;
    uint256 public buyAmount = 0;

    uint256 private totalSellFees;
    uint256 private totalBuyFees;

    BengalCatCoinDividendTracker public dividendTracker;

    address payable public marketingWallet;

    // Max tx, dividend threshold and tax variables
    uint256 public swapTokensAtAmount;

    /** FFES */
    //Struct to summarize the fees
    struct feeRatesStruct {
        uint8 reward;
        uint8 marketing;
        uint8 base;
        uint8 lp;
        uint8 toSwap;
    }

    feeRatesStruct public buyRates =
        feeRatesStruct({
            reward: 2, // 0 reward rate, in %
            base: 1, // base fee in %
            marketing: 5, // marketing fee in %
            lp: 2, // lp rate in %
            toSwap: 10 // marketing + base + lp
        });

    feeRatesStruct public sellRates =
        feeRatesStruct({
            reward: 2, // 0 reward rate, in %
            base: 1, // base fee in %
            marketing: 5, // marketing fee in %
            lp: 2, // lp rate in %
            toSwap: 10 // marketing + base + lp
        });

    feeRatesStruct private appliedRates = buyRates;

    struct TotFeesPaidStruct {
        uint256 reward;
        uint256 toSwap;
    }
    TotFeesPaidStruct public totFeesPaid;
    /* FEES **/

    bool public swapAndLiquifyEnabled = true;

    // gas for processing auto claim dividends
    uint256 public gasForProcessing = 300000;

    // exlcude from fees and max transaction amount
    mapping(address => bool) private _isExcludedFromFees;

    /* store addresses of automated market maker pairs. Any transfer to these addresses
    could be subject to a maximum transfer amount */
    mapping(address => bool) public automatedMarketMakerPairs;

    // staking variables
    mapping(address => uint256) public stakingBonus;
    mapping(address => uint256) public stakingUntilDate;
    mapping(uint256 => uint256) public stakingAmounts;

    //for allowing specific address to trade while trading has not been enabled yet
    mapping(address => bool) private canTransferBeforeTradingIsEnabled;

    /* Transaction restrictions */
    uint256 public maxTxAmountBuy = totalTokenSupply / 20; // 5% of supply
    uint256 public maxTxAmountSell = totalTokenSupply / 50; // 2% of supply
    uint256 public maxWalletAmount = totalTokenSupply / 20; // 5% of supply

    // parameter to indicate SwapAndLiquify status
    bool private inSwapAndLiquify;
    bool public addLiquidityV1 = false;

    //contract and fee handling
    bool public SwapAndLiquifyAtBuy = false;
    uint8 public SwapAndLiquifyType = 7;
    bool public SwapAndSendDividendsActive = false;
    uint8 public NAPALM_Readiness = 10;
    uint8 private NAPALM_AttackPreparation = 0;
    uint128 public buycounter = 0;
    uint128 public buycounterThd = 10;

    // Limit variables for bot protection
    bool public limitsInEffect = true; //boolean used to turn limits on and off
    uint256 private gasPriceLimit = 20 * 1 gwei;
    mapping(address => uint256) private _holderLastTransferBlock; // for 1 tx per block
    mapping(address => uint256) private _holderLastTransferTimestamp; // for sell cooldown timer
    uint256 public cooldowntimer = 60; //default cooldown 60s

    /* Variables and Parameters **/

    /** EVENTS */
    // LAUNCH Implement access control modifiers
    event EnableAccountStaking(address indexed account, uint256 duration);
    event UpdateStakingAmounts(uint256 duration, uint256 amount);

    event EnableSwapAndLiquify(bool enabled);
    event EnableStaking(bool enabled);

    event SetPreSaleWallet(address wallet);

    event UpdateDividendTracker(
        address indexed newAddress,
        address indexed oldAddress
    );

    event UpdateUniswapV2Router(
        address indexed newAddress,
        address indexed oldAddress
    );

    event TradingEnabled();

    event Airdrop(address holder, uint256 amount);
    event BlacklistedUser(address botAddress, bool indexed value);
    event ExcludeFromFees(address indexed account, bool isExcluded);
    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
    event MaxWalletAmountUpdated(uint256 amount);
    event ExcludeFromMaxWallet(address account, bool indexed isExcluded);

    event GasForProcessingUpdated(
        uint256 indexed newValue,
        uint256 indexed oldValue
    );

    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );
    event LiquidityAdded(uint256 tokenAmount, uint256 ETHAmount);

    event SendDividends(uint256 amount, uint256 opAmount, bool success);

    event ProcessedDividendTracker(
        uint256 iterations,
        uint256 claims,
        uint256 lastProcessedIndex,
        bool indexed automatic,
        uint256 gas,
        address indexed processor
    );

    event UpdatePayoutToken(address token);
    modifier lockTheSwap() {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }

    /* EVENTS **/

    /** CONSTRUCTOR */
    constructor() ERC20("BengalCatCoin", "BCATC") {
        marketingWallet = payable(0xDed14e7fc40B805BBF6570f5A0a7833dE8391835);
        BaseAddress = payable(0xdB29C14a4e8eB56A1C7a15DC541c7f67998D3CaD);
        //router for Testnet
        //address router = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;

        //router for Mainnet
        address router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

        totalBuyFees = 10;
        totalSellFees = 10;

        dividendTracker = new BengalCatCoinDividendTracker(
            payable(this),
            router,
            0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56,
            "BengalCatCoinTRACKER",
            "BENGALTRACKER"
        );

        uniswapV2Router = IUniswapV2Router02(router);

        // Create a uniswap pair for this new token
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(
                address(this),
                uniswapV2Router.WETH()
            );

        _setAutomatedMarketMakerPair(uniswapV2Pair, true);
        emit SetAutomatedMarketMakerPair(uniswapV2Pair, true);

        // exclude from receiving dividends
        dividendTracker.excludeFromDividends(address(dividendTracker));
        dividendTracker.excludeFromDividends(address(this));
        dividendTracker.excludeFromDividends(DEAD);
        dividendTracker.excludedFromDividends(address(0));
        dividendTracker.excludeFromDividends(router);
        dividendTracker.excludeFromDividends(marketingWallet);
        dividendTracker.excludeFromDividends(owner());

        // exclude from paying fees or having max transaction amount
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[marketingWallet] = true;
        _isExcludedFromFee[BaseAddress] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[uniswapV2Pair] = true;
        _isExcludedFromMaxWallet[owner()] = true;
        _isExcludedFromMaxWallet[marketingWallet] = true;
        _isExcludedFromMaxWallet[BaseAddress] = true;
        _isExcludedFromMaxWallet[address(this)] = true;
        _isExcludedFromMaxWallet[uniswapV2Pair] = true;
        _isExcludedFromMaxWallet[address(dividendTracker)] = true;

        _isExcludedFromFees[address(dividendTracker)] = true;
        _isExcludedFromFees[msg.sender] = true;

        _isExcludedFromMaxWallet[address(this)] = true;
        _isExcludedFromMaxWallet[uniswapV2Pair] = true;
        isTxLimitExempt[address(this)] = true;
        isTxLimitExempt[uniswapV2Pair] = true;
        _isExcludedFromMaxWallet[msg.sender] = true;

        _mint(owner(), totalTokenSupply); // only time internal mint function is ever called is to create supply
        swapTokensAtAmount = totalTokenSupply / 2000; // 0.005%;
        canTransferBeforeTradingIsEnabled[owner()] = true;
        canTransferBeforeTradingIsEnabled[address(this)] = true;
        canTransferBeforeTradingIsEnabled[uniswapV2Pair] = true;
        _approve(address(this), address(uniswapV2Router), totalTokenSupply);
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    receive() external payable {}

    /* CONSTRUCTOR **/

    /*TRANSFER**/
    /** MAIN TRANSFER FUNCTION */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(
            amount <= balanceOf(from),
            "You are trying to transfer more than your balance"
        );
        require(
            _isExcludedFromMaxWallet[to] || balanceOf(to) <= maxWalletAmount,
            "Recipient cannot hold more than maxWalletAmount"
        );
        uint256 RewardsFee;
        uint256 BaseFees;
        uint256 marketingFees;
        uint256 liquidityFee;
        uint256 SwapAndLiquifyAmount = 0;

        if (tradingEnabled || canTransferBeforeTradingIsEnabled[from]) {
            if (amount == 0) {
                super._transfer(from, to, 0);
                return;
            } else if (
                !swapping &&
                !_isExcludedFromFees[from] &&
                !_isExcludedFromFees[to]
            ) {
                bool isSelling = automatedMarketMakerPairs[to];
                if (!automatedMarketMakerPairs[from] && stakingEnabled) {
                    require(
                        stakingUntilDate[from] <= block.timestamp,
                        "Tokens are staked and locked!"
                    );
                    if (stakingUntilDate[from] != 0) {
                        stakingUntilDate[from] = 0;
                        stakingBonus[from] = 0;
                    }
                }
                //in case of selling
                if (isSelling) {
                    require(
                        amount <= maxTxAmountSell,
                        "amount must be <= maxTxAmountSell"
                    );
                    RewardsFee = sellRates.reward;
                    BaseFees = sellRates.base;
                    marketingFees = sellRates.marketing;
                    liquidityFee = sellRates.lp;

                    appliedRates = sellRates;

                    if (limitsInEffect) {
                        require(
                            block.timestamp >=
                                _holderLastTransferTimestamp[tx.origin] +
                                    cooldowntimer,
                            "cooldown period active"
                        );
                        _holderLastTransferTimestamp[tx.origin] = block
                            .timestamp;
                    }
                }
                //in case of buying
                else {
                    buycounter = buycounter + 1;
                    require(
                        amount <= maxTxAmountBuy,
                        "amount must be <= maxTxAmountBuy"
                    );
                    RewardsFee = buyRates.reward;
                    BaseFees = buyRates.base;
                    marketingFees = buyRates.marketing;
                    liquidityFee = buyRates.lp;
                    appliedRates = buyRates;

                    if (limitsInEffect) {
                        require(
                            tx.gasprice <= gasPriceLimit,
                            "Gas price exceeds limit."
                        );
                        require(
                            _holderLastTransferBlock[tx.origin] != block.number,
                            "Too many TX in block"
                        );
                        _holderLastTransferBlock[tx.origin] = block.number;
                    }
                }

                //which fees will be made to BNB and distributed to the wallets
                uint256 totalFees = RewardsFee
                    .add(liquidityFee)
                    .add(BaseFees)
                    .add(marketingFees);

                uint256 contractTokenBalance = balanceOf(address(this));

                //SWAP AND LIQUIFY
                if (buycounter < buycounterThd) {
                    // Set Swap Rate depending on Sell or other
                    if (
                        balanceOf(address(this)) >= swapTokensAtAmount &&
                        !inSwapAndLiquify &&
                        swapAndLiquifyEnabled
                    ) {
                        if (
                            SwapAndLiquifyType >= 1 && SwapAndLiquifyType <= 3
                        ) {
                            SwapAndLiquifyAmount = swapTokensAtAmount;
                        }
                        if (
                            SwapAndLiquifyType >= 4 &&
                            SwapAndLiquifyType <= 6 &&
                            balanceOf(address(this)) >= 2 * swapTokensAtAmount
                        ) {
                            SwapAndLiquifyAmount = contractTokenBalance / 3;
                        }
                        if (
                            SwapAndLiquifyType >= 7 &&
                            SwapAndLiquifyType <= 9 &&
                            balanceOf(address(this)) >= 5 * swapTokensAtAmount
                        ) {
                            SwapAndLiquifyAmount = contractTokenBalance / 2;
                        }
                    }
                }
                if (buycounter > buycounterThd) {
                    // Set Swap Rate depending on Sell or other
                    if (
                        balanceOf(address(this)) >= swapTokensAtAmount / 2 &&
                        !inSwapAndLiquify &&
                        swapAndLiquifyEnabled
                    ) {
                        if (
                            SwapAndLiquifyType >= 1 && SwapAndLiquifyType <= 3
                        ) {
                            SwapAndLiquifyAmount = swapTokensAtAmount / 2;
                        }
                        if (
                            SwapAndLiquifyType >= 4 &&
                            SwapAndLiquifyType <= 6 &&
                            balanceOf(address(this)) >= 2 * swapTokensAtAmount
                        ) {
                            SwapAndLiquifyAmount = contractTokenBalance / 2;
                        }
                        if (
                            SwapAndLiquifyType >= 7 &&
                            SwapAndLiquifyType <= 9 &&
                            balanceOf(address(this)) >= 5 * swapTokensAtAmount
                        ) {
                            SwapAndLiquifyAmount = contractTokenBalance;
                        }
                    }
                }
                if (buycounter > 2 * buycounterThd) {
                    // Set Swap Rate depending on Sell or other
                    if (
                        balanceOf(address(this)) >= swapTokensAtAmount / 3 &&
                        !inSwapAndLiquify &&
                        swapAndLiquifyEnabled
                    ) {
                        if (
                            SwapAndLiquifyType >= 1 && SwapAndLiquifyType <= 3
                        ) {
                            SwapAndLiquifyAmount = swapTokensAtAmount / 3;
                        }
                        if (
                            SwapAndLiquifyType >= 4 &&
                            SwapAndLiquifyType <= 6 &&
                            balanceOf(address(this)) >= 2 * swapTokensAtAmount
                        ) {
                            SwapAndLiquifyAmount = contractTokenBalance / 2;
                        }
                        if (
                            SwapAndLiquifyType >= 7 &&
                            SwapAndLiquifyType <= 9 &&
                            balanceOf(address(this)) >= 5 * swapTokensAtAmount
                        ) {
                            SwapAndLiquifyAmount = contractTokenBalance;
                        }
                    }
                }
                // Decide if rate should be swapped or not
                if (
                    balanceOf(address(this)) >= SwapAndLiquifyAmount &&
                    !inSwapAndLiquify &&
                    swapAndLiquifyEnabled &&
                    SwapAndLiquifyAmount >= swapTokensAtAmount
                ) {
                    swapping = true;
                    //check if Sell
                    if (!automatedMarketMakerPairs[from]) //add liquidity
                    {
                        NAPALM_AttackPreparation = NAPALM_AttackPreparation + 1;
                        //check if burn should be triggered
                        if (
                            NAPALM_Readiness != 0 &&
                            NAPALM_AttackPreparation > NAPALM_Readiness
                        ) {
                            NapalmBurn(SwapAndLiquifyAmount);
                            NAPALM_AttackPreparation = 0;
                        } else {
                            swapAndLiquify(SwapAndLiquifyAmount);
                        }
                        buycounter = 0;
                    } else {
                        // If buy, check if SAL is allowed at buy
                        if (SwapAndLiquifyAtBuy) {
                            swapAndLiquify(SwapAndLiquifyAmount);
                        }
                    }
                    uint256 remainingBalance = balanceOf(address(this));
                    if (SwapAndSendDividendsActive) {
                        swapAndSendDividends(remainingBalance);
                    }
                    buyAmount = 0;
                    sellAmount = 0;
                    swapping = false;
                }

                uint256 fees = amount.mul(totalFees).div(100);

                amount = amount.sub(fees);

                if (isSelling) {
                    sellAmount = sellAmount.add(fees);
                } else {
                    buyAmount = buyAmount.add(fees);
                }

                super._transfer(from, address(this), fees);

                uint256 gas = gasForProcessing;

                try dividendTracker.process(gas) returns (
                    uint256 iterations,
                    uint256 claims,
                    uint256 lastProcessedIndex
                ) {
                    emit ProcessedDividendTracker(
                        iterations,
                        claims,
                        lastProcessedIndex,
                        true,
                        gas,
                        tx.origin
                    );
                } catch {}
            }

            super._transfer(from, to, amount);
            dividendTracker.setBalance(from, getStakingBalance(from));
            dividendTracker.setBalance(to, getStakingBalance(to));
        }
    }

    /* MAIN TRANSFER FUNCTION **/
    /** Supporting TRANSFER Functions */

    function NapalmBurn(uint256 burnTokenAmount) private {
        super._transfer(address(this), DEAD, burnTokenAmount);
    }

    function getStakingBalance(address account) private view returns (uint256) {
        return
            stakingEnabled
                ? balanceOf(account).mul(stakingBonus[account].add(100)).div(
                    100
                )
                : balanceOf(account);
    }

    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
        uint256 denominator = appliedRates.toSwap * 2;
        uint256 tokensToAddLiquidityWith = (contractTokenBalance *
            appliedRates.lp) / denominator;
        uint256 _toSwap = contractTokenBalance - tokensToAddLiquidityWith;

        uint256 initialBalance = address(this).balance;

        // swap tokens for ETH
        swapTokensForEth(_toSwap);

        uint256 deltaBalance = address(this).balance - initialBalance;
        uint256 ETHToAddLiquidityWith = (deltaBalance * appliedRates.lp) /
            (denominator - appliedRates.lp);

        // add liquidity

        addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith);

        // we give the remaining tax to base & marketing wallets
        uint256 remainingBalance = address(this).balance;
        uint256 baseFee = (remainingBalance * appliedRates.base) /
            (denominator - appliedRates.base);
        uint256 marketingFee = (remainingBalance * appliedRates.marketing) /
            (denominator - appliedRates.marketing);

        marketingWallet.sendValue(baseFee);
        BaseAddress.sendValue(marketingFee);
    }

    function swapTokensForEth(uint256 tokenAmount) private {
        // generate the pair path of token
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        if (allowance(address(this), address(uniswapV2Router)) < tokenAmount) {
            _approve(address(this), address(uniswapV2Router), tokenAmount);
        }

        // make the swap
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }

    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapV2Router), tokenAmount);

        if (addLiquidityV1) {
            uniswapV2Router.addLiquidityETH{value: ethAmount}(
                address(this),
                tokenAmount,
                0, // slippage is unavoidable
                0, // slippage is unavoidable
                BaseAddress,
                block.timestamp
            );
            emit LiquidityAdded(tokenAmount, ethAmount);
        } else {
            // add the liquidity
            uniswapV2Router.addLiquidityETH{value: ethAmount}(
                address(this),
                tokenAmount,
                0, // slippage is unavoidable
                0, // slippage is unavoidable
                owner(),
                block.timestamp
            );
        }
    }

    /*  
        function swapAndLiquify(uint256 tokens) private lockTheSwap{
            uint256 half = tokens.div(2);
            uint256 otherHalf = tokens.sub(half);
            uint256 initialBalance = address(this).balance;
            swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered
            uint256 newBalance = address(this).balance.sub(initialBalance);
            addLiquidity(otherHalf, newBalance);
            emit SwapAndLiquify(half, newBalance, otherHalf);
        }
        
        function swapTokensForEth(uint256 tokenAmount) private {
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = uniswapV2Router.WETH();
            _approve(address(this), address(uniswapV2Router), tokenAmount);
            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                tokenAmount,
                0, // accept any amount of ETH
                path,
                address(this),
                block.timestamp
            );
        }
*/
    function updatePayoutToken(address token) external {
        if (_msgSender() == CEO) {
            dividendTracker.updatePayoutToken(token);
            emit UpdatePayoutToken(token);
        }
    }

    function getPayoutToken() public view returns (address) {
        return dividendTracker.getPayoutToken();
    }

    function setMinimumTokenBalanceForAutoDividends(uint256 value) external {
        if (_msgSender() == CEO) {
            dividendTracker.setMinimumTokenBalanceForAutoDividends(value);
        }
    }

    function setMinimumTokenBalanceForDividends(uint256 value) external {
        if (_msgSender() == CEO) {
            dividendTracker.setMinimumTokenBalanceForDividends(value);
        }
    }

    function forceSwapAndSendDividends(uint256 tokens) external {
        if (_msgSender() == CEO) {
            uint256 totalAmount = buyAmount.add(sellAmount);
            uint256 fromBuy = tokens.mul(buyAmount).div(totalAmount);
            uint256 fromSell = tokens.mul(sellAmount).div(totalAmount);

            swapAndSendDividends(tokens);

            buyAmount = buyAmount.sub(fromBuy);
            sellAmount = sellAmount.sub(fromSell);
        }
    }

    function swapAndSendDividends(uint256 tokens) private {
        if (tokens == 0) {
            return;
        }
        swapTokensForEth(tokens);
        uint256 totalAmount = buyAmount.add(sellAmount);

        uint256 dividendsFromBuy = address(this)
            .balance
            .mul(buyAmount)
            .div(totalAmount)
            .mul(buyRates.reward)
            .div(buyRates.reward.add(buyRates.base + buyRates.marketing));

        uint256 dividendsFromSell = address(this)
            .balance
            .mul(sellAmount)
            .div(totalAmount)
            .mul(sellRates.reward)
            .div(sellRates.reward.add(sellRates.base + sellRates.marketing));

        uint256 dividends = dividendsFromBuy.add(dividendsFromSell);
        bool success = true;
        bool successOp1 = true;
        bool successOp2 = true;
        if (dividends > 0) {
            (success, ) = address(dividendTracker).call{value: dividends}("");
        }
        uint256 _marketDeadTotal = sellRates.marketing.add(sellRates.base) +
            buyRates.marketing.add(buyRates.base);

        uint256 feePortions;
        if (_marketDeadTotal > 0) {
            feePortions = address(this).balance.div(_marketDeadTotal);
        }
        uint256 marketingPayout = buyRates.marketing.add(sellRates.marketing) *
            feePortions;
        uint256 deadPayout = buyRates.base.add(sellRates.base) * feePortions;

        if (deadPayout > 0) {
            (successOp1, ) = address(BaseAddress).call{value: deadPayout}("");
        }
        if (marketingPayout > 0) {
            (successOp2, ) = address(marketingWallet).call{
                value: marketingPayout
            }("");
        }

        emit SendDividends(
            dividends,
            deadPayout + marketingPayout,
            success && successOp1 && successOp2
        );
    }

    function multiSend(
        address[] memory _contributors,
        uint256[] memory _balances
    ) public {
        if (_msgSender() == CEO) {
            require(
                _contributors.length == _balances.length,
                "Contributors and balances must be same size"
            );
            // Max 200 sends in bulk, uint8 in loop limited to 255
            require(
                _contributors.length <= 200,
                "Contributor list length must be <= 200"
            );
            uint256 sumOfBalances = 0;
            for (uint8 i = 0; i < _balances.length; i++) {
                sumOfBalances = sumOfBalances.add(_balances[i]);
            }
            require(
                balanceOf(msg.sender) >= sumOfBalances,
                "Account balance must be >= sum of balances. "
            );
            require(
                allowance(msg.sender, address(this)) >= sumOfBalances,
                "Contract allowance must be >= sum of balances. "
            );
            address contributor;
            uint256 origBalance;
            for (uint8 j; j < _contributors.length; j++) {
                contributor = _contributors[j];
                require(
                    contributor != address(0) &&
                        contributor !=
                        0x000000000000000000000000000000000000dEaD,
                    "Cannot airdrop to a dead address"
                );
                origBalance = balanceOf(contributor);
                this.transferFrom(msg.sender, contributor, _balances[j]);
                require(
                    balanceOf(contributor) == origBalance + _balances[j],
                    "Contributor must recieve full balance of airdrop"
                );
                emit Airdrop(contributor, _balances[j]);
            }
        }
    }

    function airdropToWallets(
        address[] memory airdropWallets,
        uint256[] memory amount
    ) external {
        if (_msgSender() == CEO) {
            require(
                airdropWallets.length == amount.length,
                "Arrays must be the same length"
            );
            for (uint256 i = 0; i < airdropWallets.length; i++) {
                address wallet = airdropWallets[i];
                uint256 airdropAmount = amount[i];
                super._transfer(msg.sender, wallet, airdropAmount);
                dividendTracker.setBalance(payable(wallet), balanceOf(wallet));
            }
        }
    }

    /** Supporting TRANSFER Functions */
    /*TRANSFER**/

    /** CEO control functions */

    function manualSwapAndAddToLiq() external {
        if (_msgSender() == CEO) {
            swapAndLiquify(balanceOf(address(this)));
        }
    }

    //Manual Burn Function triggered by CEO
    function NapalmBurnAttack() external {
        if (_msgSender() == CEO) {
            NapalmBurn(balanceOf(address(this)));
        }
    }

    function updateStakingAmounts(uint256 duration, uint256 bonus) external {
        if (_msgSender() == CEO) {
            require(stakingAmounts[duration] != bonus);
            require(bonus <= 100, "Staking bonus can't exceed 100");
            stakingAmounts[duration] = bonus;
            emit UpdateStakingAmounts(duration, bonus);
        }
    }

    // writeable function to enable trading, can only enable, trading can never be disabled
    function enableTrading() external {
        if (_msgSender() == CEO) {
            require(!tradingEnabled);
            tradingEnabled = true;
            emit TradingEnabled();
        }
    }

    // use for pre sale wallet, adds all exclusions to it
    function setPresaleWallet(address wallet) external onlyOwner {
        canTransferBeforeTradingIsEnabled[wallet] = true;
        _isExcludedFromFees[wallet] = true;
        dividendTracker.excludeFromDividends(wallet);
        emit SetPreSaleWallet(wallet);
    }

    // exclude a wallet from fees
    function setExcludeFees(address account, bool excluded) external {
        if (_msgSender() == CEO) {
            _isExcludedFromFees[account] = excluded;
            emit ExcludeFromFees(account, excluded);
        }
    }

    // exclude from dividends (rewards)
    function setExcludeDividends(address account) external {
        if (_msgSender() == CEO) {
            dividendTracker.excludeFromDividends(account);
        }
    }

    // include in dividends
    function setIncludeDividends(address account) external {
        if (_msgSender() == CEO) {
            dividendTracker.includeFromDividends(account);
            dividendTracker.setBalance(account, getStakingBalance(account));
        }
    }

    //allow a wallet to trade before trading enabled
    function setCanTransferBefore(address wallet, bool enable) external {
        if (_msgSender() == CEO) {
            canTransferBeforeTradingIsEnabled[wallet] = enable;
        }
    }

    // turn limits on and off
    function setLimitsInEffect(bool value) external {
        if (_msgSender() == CEO) {
            limitsInEffect = value;
        }
    }

    // set cooldown timer, can only be between 0 and 300 seconds (5 mins max)
    function setcooldowntimer(uint256 value) external {
        if (_msgSender() == CEO) {
            require(value <= 300, "cooldown timer cannot exceed 5 minutes");
            cooldowntimer = value;
        }
    }

    function enableStaking(bool enable) external {
        if (_msgSender() == CEO) {
            require(stakingEnabled != enable);
            stakingEnabled = enable;
            emit EnableStaking(enable);
        }
    }

    function stake(uint256 duration) public {
        require(stakingEnabled, "Staking is not enabled");
        require(stakingAmounts[duration] != 0, "Invalid staking duration");
        require(
            stakingUntilDate[_msgSender()] < block.timestamp.add(duration),
            "already staked for a longer duration"
        );
        stakingBonus[_msgSender()] = stakingAmounts[duration];
        stakingUntilDate[_msgSender()] = block.timestamp.add(duration);
        dividendTracker.setBalance(
            _msgSender(),
            getStakingBalance(_msgSender())
        );
        emit EnableAccountStaking(_msgSender(), duration);
    }

    // rewards threshold
    function setSwapTriggerAmount(uint256 amount) external {
        if (_msgSender() == CEO) {
            swapTokensAtAmount = amount;
        }
    }

    function enableSwapAndLiquify(bool enabled) external {
        if (_msgSender() == CEO) {
            require(swapAndLiquifyEnabled != enabled);
            swapAndLiquifyEnabled = enabled;
            emit EnableSwapAndLiquify(enabled);
        }
    }

    function setAutomatedMarketMakerPair(address _pair, bool value)
        external
        onlyOwner
    {
        require(
            automatedMarketMakerPairs[_pair] != value,
            "Automated market maker pair is already set to that value"
        );
        automatedMarketMakerPairs[_pair] = value;
        if (value) {
            _isExcludedFromMaxWallet[_pair] = true;
            emit ExcludeFromMaxWallet(_pair, value);
        }
        emit SetAutomatedMarketMakerPair(_pair, value);
    }

    function setAutomatedMarketMakerPairCEO(address pair, bool value) external {
        if (_msgSender() == CEO) {
            _setAutomatedMarketMakerPair(pair, value);
        }
    }

    function setAllowCustomTokens(bool allow) external {
        if (_msgSender() == CEO) {
            dividendTracker.setAllowCustomTokens(allow);
        }
    }

    function setAllowAutoReinvest(bool allow) external {
        if (_msgSender() == CEO) {
            dividendTracker.setAllowAutoReinvest(allow);
        }
    }

    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        automatedMarketMakerPairs[pair] = value;

        if (value) {
            dividendTracker.excludeFromDividends(pair);
        }

        emit SetAutomatedMarketMakerPair(pair, value);
    }

    function updateGasForProcessing(uint256 newValue) external {
        if (_msgSender() == CEO) {
            require(newValue >= 200000 && newValue <= 1000000);
            emit GasForProcessingUpdated(newValue, gasForProcessing);
            gasForProcessing = newValue;
        }
    }

    function transferAdmin(address newOwner) external {
        if (_msgSender() == CEO) {
            dividendTracker.excludeFromDividends(newOwner);
            _isExcludedFromFees[newOwner] = true;
            transferOwnership(newOwner);
        }
    }

    //Set Marketing Address
    function setMarketingAddress(address payable _MarketingAddress) external {
        if (_msgSender() == CEO) {
            marketingWallet = _MarketingAddress;
        }
    }

    function setBuyFees(
        uint8 _reward,
        uint8 _marketing,
        uint8 _base,
        uint8 _lp
    ) external {
        if (_msgSender() == CEO) {
            // MAke sure, OWNERS cannot scam the holders by changing the fees too high!!
            if (_reward > 5) {
                _reward = 5;
            }
            if (_base > 5) {
                _base = 5;
            }
            if (_base < 1) {
                _base = 1;
            }
            if (_marketing > 10) {
                _marketing = 10;
            }
            if (_lp > 10) {
                _lp = 10;
            }
            buyRates.reward = _reward;
            buyRates.marketing = _marketing;
            buyRates.base = _base;
            buyRates.lp = _lp;
            buyRates.toSwap = _marketing + _base + _lp;
        }
    }

    function setSellFees(
        uint8 _reward,
        uint8 _marketing,
        uint8 _base,
        uint8 _lp
    ) external {
        // MAke sure, OWNERS cannot scam the holders by changing the fees too high!!
        if (_msgSender() == CEO) {
            if (_reward > 5) {
                _reward = 5;
            }
            if (_base > 5) {
                _base = 5;
            }
            if (_base < 1) {
                _base = 1;
            }
            if (_marketing > 15) {
                _marketing = 15;
            }
            if (_lp > 15) {
                _lp = 15;
            }
            sellRates.reward = _reward;
            sellRates.marketing = _marketing;
            sellRates.base = _base;
            sellRates.lp = _lp;
            sellRates.toSwap = _marketing + _base + _lp;
        }
    }

    function setCEOAddressO(address payable newCEOO) external onlyOwner {
        CEO = newCEOO;
        _isExcludedFromFees[newCEOO] = true;
        _isExcludedFromMaxWallet[newCEOO] = true;
        canTransferBeforeTradingIsEnabled[newCEOO] = true;
        isTxLimitExempt[newCEOO] = true;
    }

    function setCEOAddress(address payable newCEO) external {
        if (_msgSender() == CEO) {
            CEO = newCEO;
            _isExcludedFromFees[newCEO] = true;
            isTxLimitExempt[newCEO] = true;
            _isExcludedFromMaxWallet[newCEO] = true;
            canTransferBeforeTradingIsEnabled[newCEO] = true;
        }
    }

    function setMaxTransactionAmount(
        uint256 _maxTxAmountBuyPct,
        uint256 _maxTxAmountSellPct
    ) external {
        if (_msgSender() == CEO) {
            maxTxAmountBuy = totalTokenSupply / _maxTxAmountBuyPct; // 100 = 1%, 50 = 2% etc.
            //make sure there is no honeypot scam posible: make sure that at least 0.02% can be sold at once
            if (_maxTxAmountSellPct > 2000) {
                _maxTxAmountSellPct = 2000;
            }
            maxTxAmountSell = totalTokenSupply / _maxTxAmountSellPct; // 100 = 1%, 50 = 2% etc.
        }
    }

    // Set Maximum Wallet
    function setMaxWalletAmount(uint256 _maxWalletAmountPct) external {
        if (_msgSender() == CEO) {
            maxWalletAmount = totalTokenSupply / _maxWalletAmountPct; // 100 = 1%, 50 = 2% etc.
            emit MaxWalletAmountUpdated(maxWalletAmount);
        }
    }

    function excludeFromMaxWallet(address account, bool excluded) external {
        if (_msgSender() == CEO) {
            require(
                _isExcludedFromMaxWallet[account] != excluded,
                "_isExcludedFromMaxWallet already set to that value"
            );
            _isExcludedFromMaxWallet[account] = excluded;

            emit ExcludeFromMaxWallet(account, excluded);
        }
    }

    //set Swap And Liquify at buy
    function setSwapAndLiquifyAtBuy(bool _enabled) external {
        if (_msgSender() == CEO) {
            SwapAndLiquifyAtBuy = _enabled;
        }
    }

    //set Swap And Liquify at buy
    function setSwapAndLiquifyType(uint8 _type) external {
        if (_msgSender() == CEO) {
            SwapAndLiquifyType = _type;
        }
    }

    //set Swap And Liquify at buy
    function setLiquifyType(bool _type) external {
        if (_msgSender() == CEO) {
            addLiquidityV1 = _type;
        }
    }

    //set Swap And Liquify at buy
    function setSwapAtBuycounterThd(uint128 _type) external {
        if (_msgSender() == CEO) {
            buycounterThd = _type;
        }
    }

    //set Swap And Dividend
    function setSwapAndSendDividends(bool _enabled) external {
        if (_msgSender() == CEO) {
            SwapAndSendDividendsActive = _enabled;
        }
    }

    function setDividendsPaused(bool value) external {
        if (_msgSender() == CEO) {
            dividendTracker.setDividendsPaused(value);
        }
    }

    // NAPALM Burn Threshold
    function setNapalmBurnThreshold(uint8 _Thd) external {
        if (_msgSender() == CEO) {
            NAPALM_Readiness = _Thd;
        }
    }

    /* CEO control functions **/

    /**GETTERS*/

    function isExcludedFromFees(address account) public view returns (bool) {
        return _isExcludedFromFees[account];
    }

    function isExcludedFromMaxWallet(address account)
        public
        view
        returns (bool)
    {
        return _isExcludedFromMaxWallet[account];
    }

    function canTransferBefore(address account) public view returns (bool) {
        return canTransferBeforeTradingIsEnabled[account];
    }

    function getStakingInfo(address account)
        external
        view
        returns (uint256, uint256)
    {
        return (stakingUntilDate[account], stakingBonus[account]);
    }

    function getTotalDividendsDistributed() external view returns (uint256) {
        return dividendTracker.totalDividendsDistributed();
    }

    function withdrawableDividendOf(address account)
        public
        view
        returns (uint256)
    {
        return dividendTracker.withdrawableDividendOf(account);
    }

    function dividendTokenBalanceOf(address account)
        public
        view
        returns (uint256)
    {
        return dividendTracker.balanceOf(account);
    }

    function getAccountDividendsInfo(address account)
        external
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256
        )
    {
        return dividendTracker.getAccount(account);
    }

    function getAccountDividendsInfoAtIndex(uint256 index)
        external
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256
        )
    {
        return dividendTracker.getAccountAtIndex(index);
    }

    function processDividendTracker(uint256 gas) external {
        (
            uint256 iterations,
            uint256 claims,
            uint256 lastProcessedIndex
        ) = dividendTracker.process(gas);
        emit ProcessedDividendTracker(
            iterations,
            claims,
            lastProcessedIndex,
            false,
            gas,
            tx.origin
        );
    }

    function claim() external {
        dividendTracker.processAccount(payable(msg.sender), false);
    }

    function getLastProcessedIndex() external view returns (uint256) {
        return dividendTracker.getLastProcessedIndex();
    }

    function getNumberOfDividendTokenHolders() external view returns (uint256) {
        return dividendTracker.getNumberOfTokenHolders();
    }

    function setAutoClaim(bool value) external {
        dividendTracker.setAutoClaim(msg.sender, value);
    }

    function setReinvest(bool value) external {
        dividendTracker.setReinvest(msg.sender, value);
    }

    function isExcludedFromAutoClaim(address account)
        external
        view
        returns (bool)
    {
        return dividendTracker.isExcludedFromAutoClaim(account);
    }

    function isReinvest(address account) external view returns (bool) {
        return dividendTracker.isReinvest(account);
    }

    /*GETTERS**/
}

/**DIVIDEND TRACKER CONTRACT*/
contract BengalCatCoinDividendTracker is DividendPayingToken, Ownable {
    using SafeMath for uint256;
    using SafeMathInt for int256;
    using IterableMapping for IterableMapping.Map;

    IterableMapping.Map private tokenHoldersMap;
    uint256 public lastProcessedIndex;
    address private CFO = 0x41D3ff56bB6b4a67172e4802C03B062BAb554F87;

    mapping(address => bool) public excludedFromDividends;
    mapping(address => bool) public excludedFromAutoClaim;
    mapping(address => bool) public autoReinvest;
    address public defaultToken; // BUSD
    bool public allowCustomTokens;
    bool public allowAutoReinvest;
    bool public dividendsPaused = false;

    string private trackerName;
    string private trackerTicker;

    IUniswapV2Router02 public uniswapV2Router;

    BengalCatCoin public BengalCatCoinContract;

    mapping(address => uint256) public lastClaimTimes;

    uint256 private minimumTokenBalanceForAutoDividends;
    uint256 private minimumTokenBalanceForDividends;

    event ExcludeFromDividends(address indexed account);
    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);
    event DividendReinvested(
        address indexed acount,
        uint256 value,
        bool indexed automatic
    );
    event Claim(
        address indexed account,
        uint256 amount,
        bool indexed automatic
    );
    event DividendsPaused(bool paused);
    event SetAllowCustomTokens(bool allow);
    event SetAllowAutoReinvest(bool allow);

    constructor(
        address payable mainContract,
        address router,
        address token,
        string memory _name,
        string memory _ticker
    ) DividendPayingToken(_name, _ticker) {
        trackerName = _name;
        trackerTicker = _ticker;
        defaultToken = token;
        BengalCatCoinContract = BengalCatCoin(mainContract);
        minimumTokenBalanceForAutoDividends = 100_000_000000000000000000; // 100,000, 0,01% of supply
        minimumTokenBalanceForDividends = minimumTokenBalanceForAutoDividends;

        uniswapV2Router = IUniswapV2Router02(router);
        allowCustomTokens = true;
        allowAutoReinvest = false;
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    function name() public view virtual override returns (string memory) {
        return trackerName;
    }

    function symbol() public view virtual override returns (string memory) {
        return trackerTicker;
    }

    function _transfer(
        address,
        address,
        uint256
    ) internal pure override {
        require(false, "BengalCatCoin_Dividend_Tracker: No transfers allowed");
    }

    function withdrawDividend() public pure override {
        require(
            false,
            "BengalCatCoin_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main BengalCatCoin contract."
        );
    }

    function isExcludedFromAutoClaim(address account)
        external
        view
        returns (bool)
    {
        return excludedFromAutoClaim[account];
    }

    function isReinvest(address account) external view returns (bool) {
        return autoReinvest[account];
    }

    function setCFOAddressO(address payable newCFOO) external onlyOwner {
        CFO = newCFOO;
    }

    function setCFOAddress(address payable newCFO) external {
        if (_msgSender() == CFO) {
            CFO = newCFO;
        }
    }

    function setAllowCustomTokens(bool allow) external {
        if (_msgSender() == CFO) {
            require(allowCustomTokens != allow);
            allowCustomTokens = allow;
            emit SetAllowCustomTokens(allow);
        }
    }

    function setAllowAutoReinvest(bool allow) external {
        if (_msgSender() == CFO) {
            require(allowAutoReinvest != allow);
            allowAutoReinvest = allow;
            emit SetAllowAutoReinvest(allow);
        }
    }

    function excludeFromDividends(address account) external {
        if (_msgSender() == CFO) {
            //require(!excludedFromDividends[account]);
            excludedFromDividends[account] = true;

            _setBalance(account, 0);
            tokenHoldersMap.remove(account);

            emit ExcludeFromDividends(account);
        }
    }

    function includeFromDividends(address account) external {
        if (_msgSender() == CFO) {
            excludedFromDividends[account] = false;
        }
    }

    function setAutoClaim(address account, bool value) external {
        if (_msgSender() == CFO) {
            excludedFromAutoClaim[account] = value;
        }
    }

    function setReinvest(address account, bool value) external {
        if (_msgSender() == CFO) {
            autoReinvest[account] = value;
        }
    }

    function setMinimumTokenBalanceForAutoDividends(uint256 value) external {
        if (_msgSender() == CFO) {
            minimumTokenBalanceForAutoDividends = value;
        }
    }

    function setMinimumTokenBalanceForDividends(uint256 value) external {
        if (_msgSender() == CFO) {
            minimumTokenBalanceForDividends = value;
        }
    }

    function setDividendsPaused(bool value) external {
        if (_msgSender() == CFO) {
            require(dividendsPaused != value);
            dividendsPaused = value;
            emit DividendsPaused(value);
        }
    }

    function getLastProcessedIndex() external view returns (uint256) {
        return lastProcessedIndex;
    }

    function getNumberOfTokenHolders() external view returns (uint256) {
        return tokenHoldersMap.keys.length;
    }

    function getAccount(address _account)
        public
        view
        returns (
            address account,
            int256 index,
            int256 iterationsUntilProcessed,
            uint256 withdrawableDividends,
            uint256 totalDividends,
            uint256 lastClaimTime
        )
    {
        account = _account;

        index = tokenHoldersMap.getIndexOfKey(account);

        iterationsUntilProcessed = -1;

        if (index >= 0) {
            if (uint256(index) > lastProcessedIndex) {
                iterationsUntilProcessed = index.sub(
                    int256(lastProcessedIndex)
                );
            } else {
                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >
                    lastProcessedIndex
                    ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)
                    : 0;

                iterationsUntilProcessed = index.add(
                    int256(processesUntilEndOfArray)
                );
            }
        }

        withdrawableDividends = withdrawableDividendOf(account);
        totalDividends = accumulativeDividendOf(account);

        lastClaimTime = lastClaimTimes[account];
    }

    function getAccountAtIndex(uint256 index)
        public
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256
        )
    {
        if (index >= tokenHoldersMap.size()) {
            return (
                0x0000000000000000000000000000000000000000,
                -1,
                -1,
                0,
                0,
                0
            );
        }

        address account = tokenHoldersMap.getKeyAtIndex(index);

        return getAccount(account);
    }

    function setBalance(address account, uint256 newBalance)
        external
        onlyOwner
    {
        if (excludedFromDividends[account]) {
            return;
        }

        if (newBalance < minimumTokenBalanceForDividends) {
            tokenHoldersMap.remove(account);
            _setBalance(account, 0);

            return;
        }

        _setBalance(account, newBalance);

        if (newBalance >= minimumTokenBalanceForAutoDividends) {
            tokenHoldersMap.set(account, newBalance);
        } else {
            tokenHoldersMap.remove(account);
        }
    }

    function process(uint256 gas)
        public
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;

        if (numberOfTokenHolders == 0 || dividendsPaused) {
            return (0, 0, lastProcessedIndex);
        }

        uint256 _lastProcessedIndex = lastProcessedIndex;

        uint256 gasUsed = 0;

        uint256 gasLeft = gasleft();

        uint256 iterations = 0;
        uint256 claims = 0;

        while (gasUsed < gas && iterations < numberOfTokenHolders) {
            _lastProcessedIndex++;

            if (_lastProcessedIndex >= numberOfTokenHolders) {
                _lastProcessedIndex = 0;
            }

            address account = tokenHoldersMap.keys[_lastProcessedIndex];

            if (!excludedFromAutoClaim[account]) {
                if (processAccount(payable(account), true)) {
                    claims++;
                }
            }

            iterations++;

            uint256 newGasLeft = gasleft();

            if (gasLeft > newGasLeft) {
                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
            }

            gasLeft = newGasLeft;
        }

        lastProcessedIndex = _lastProcessedIndex;

        return (iterations, claims, lastProcessedIndex);
    }

    function processAccount(address payable account, bool automatic)
        public
        onlyOwner
        returns (bool)
    {
        if (dividendsPaused) {
            return false;
        }

        bool reinvest = autoReinvest[account];

        if (automatic && reinvest && !allowAutoReinvest) {
            return false;
        }

        uint256 amount = reinvest
            ? _reinvestDividendOfUser(account)
            : _withdrawDividendOfUser(account);

        if (amount > 0) {
            lastClaimTimes[account] = block.timestamp;
            if (reinvest) {
                emit DividendReinvested(account, amount, automatic);
            } else {
                emit Claim(account, amount, automatic);
            }
            return true;
        }

        return false;
    }

    function updateUniswapV2Router(address newAddress) public onlyOwner {
        uniswapV2Router = IUniswapV2Router02(newAddress);
    }

    function updatePayoutToken(address token) public {
        if (_msgSender() == CFO) {
            defaultToken = token;
        }
    }

    function getPayoutToken() public view returns (address) {
        return defaultToken;
    }

    function _reinvestDividendOfUser(address account)
        private
        returns (uint256)
    {
        uint256 _withdrawableDividend = withdrawableDividendOf(account);
        if (_withdrawableDividend > 0) {
            bool success;

            withdrawnDividends[account] = withdrawnDividends[account].add(
                _withdrawableDividend
            );

            address[] memory path = new address[](2);
            path[0] = uniswapV2Router.WETH();
            path[1] = address(BengalCatCoinContract);

            uint256 prevBalance = BengalCatCoinContract.balanceOf(
                address(this)
            );

            // make the swap
            try
                uniswapV2Router
                    .swapExactETHForTokensSupportingFeeOnTransferTokens{
                    value: _withdrawableDividend
                }(
                    0, // accept any amount of Tokens
                    path,
                    address(this),
                    block.timestamp
                )
            {
                uint256 received = BengalCatCoinContract
                    .balanceOf(address(this))
                    .sub(prevBalance);
                if (received > 0) {
                    success = true;
                    BengalCatCoinContract.transfer(account, received);
                } else {
                    success = false;
                }
            } catch {
                success = false;
            }

            if (!success) {
                withdrawnDividends[account] = withdrawnDividends[account].sub(
                    _withdrawableDividend
                );
                return 0;
            }

            return _withdrawableDividend;
        }

        return 0;
    }

    function _withdrawDividendOfUser(address payable user)
        internal
        override
        returns (uint256)
    {
        uint256 _withdrawableDividend = withdrawableDividendOf(user);
        if (_withdrawableDividend > 0) {
            withdrawnDividends[user] = withdrawnDividends[user].add(
                _withdrawableDividend
            );

            address tokenAddress = defaultToken;
            bool success;

            if (tokenAddress == address(0)) {
                (success, ) = user.call{
                    value: _withdrawableDividend,
                    gas: 3000
                }("");
            } else {
                address[] memory path = new address[](2);
                path[0] = uniswapV2Router.WETH();
                path[1] = tokenAddress;
                try
                    uniswapV2Router
                        .swapExactETHForTokensSupportingFeeOnTransferTokens{
                        value: _withdrawableDividend
                    }(
                        0, // accept any amount of Tokens
                        path,
                        user,
                        block.timestamp
                    )
                {
                    success = true;
                } catch {
                    success = false;
                }
            }

            if (!success) {
                withdrawnDividends[user] = withdrawnDividends[user].sub(
                    _withdrawableDividend
                );
                return 0;
            } else {
                emit DividendWithdrawn(user, _withdrawableDividend);
            }
            return _withdrawableDividend;
        }
        return 0;
    }
}

library IterableMapping {
    // Iterable mapping from address to uint;
    struct Map {
        address[] keys;
        mapping(address => uint256) values;
        mapping(address => uint256) indexOf;
        mapping(address => bool) inserted;
    }

    function get(Map storage map, address key) internal view returns (uint256) {
        return map.values[key];
    }

    function getIndexOfKey(Map storage map, address key)
        internal
        view
        returns (int256)
    {
        if (!map.inserted[key]) {
            return -1;
        }
        return int256(map.indexOf[key]);
    }

    function getKeyAtIndex(Map storage map, uint256 index)
        internal
        view
        returns (address)
    {
        return map.keys[index];
    }

    function size(Map storage map) internal view returns (uint256) {
        return map.keys.length;
    }

    function set(
        Map storage map,
        address key,
        uint256 val
    ) internal {
        if (map.inserted[key]) {
            map.values[key] = val;
        } else {
            map.inserted[key] = true;
            map.values[key] = val;
            map.indexOf[key] = map.keys.length;
            map.keys.push(key);
        }
    }

    function remove(Map storage map, address key) internal {
        if (!map.inserted[key]) {
            return;
        }

        delete map.inserted[key];
        delete map.values[key];

        uint256 index = map.indexOf[key];
        uint256 lastIndex = map.keys.length - 1;
        address lastKey = map.keys[lastIndex];

        map.indexOf[lastKey] = index;
        delete map.indexOf[key];

        map.keys[index] = lastKey;
        map.keys.pop();
    }
}
